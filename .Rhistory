pupil_blink_algo2 <-  pupil_blink_algo1 %>%
# Thrid, set neg and pos threshold here we are using -5 and 5 (probably good idea to look at data)
mutate(blinks_onset_offset=ifelse(velocity_pupil <= -4 | velocity_pupil >= 4,
1, 0)) %>%
# Four turn pupil values 0 if blink detection coded as 1
mutate(blinks_pupil=ifelse(blinks_onset_offset==1, pupil==NA, pupil)) %>%
mutate(extendpupil=extend_blinks(blinks_pupil, fillback=10, fillforward=10, hz=250)) %>%
#interpolate
dplyr::mutate(interp = zoo::na.approx(extendpupil, na.rm = FALSE, rule=2))
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(diff(smooth_pupil)/diff(time), NA))
pupil_blink_algo <-  interp_graph %>%
mutate(smooth_pupil=moving_average_pupil(pupil, n=10))
pup_g1<- ggplot(pupil_blink_algo, aes(x= time, y= smooth_pupil)) +
geom_point()+ geom_line(colour="black") +
ggtitle("Smoothed Pupil Signal")
print(pup_g1)
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(diff(smooth_pupil)/diff(time), NA))
pup_g2<- ggplot(pupil_blink_algo1, aes(x= time, y= velocity_pupil)) +
geom_point()+ geom_line(colour="black") +
ggtitle("Pupil Velocity")
pup_g2
pupil_blink_algo2 <-  pupil_blink_algo1 %>%
# Thrid, set neg and pos threshold here we are using -5 and 5 (probably good idea to look at data)
mutate(blinks_onset_offset=ifelse(velocity_pupil <= -4 | velocity_pupil >= 4,
1, 0)) %>%
# Four turn pupil values 0 if blink detection coded as 1
mutate(blinks_pupil=ifelse(blinks_onset_offset==1, pupil==NA, pupil)) %>%
mutate(extendpupil=extend_blinks(blinks_pupil, fillback=10, fillforward=10, hz=250)) %>%
#interpolate
dplyr::mutate(interp = zoo::na.approx(extendpupil, na.rm = FALSE, rule=2))
pupil_blink_algo2$blink
pupil_blink_algo2$blinks_onset_offset
pupil_blink_algo2$velocity_pupil
pupil_blink_algo2$blinks_pupil
pupil_blink_algo2$extendpupil
interp_graph <- pupil_files1  %>%
dplyr::filter(subject=="11c.edf", trial=="20")
pup_g<- ggplot(interp_graph, aes(x= time, y= pupil)) + geom_point()+ geom_line(colour="black") + ggtitle("Raw Pupil Signal")
print(pup_g)
interp_graph <- pupil_files1  %>%
dplyr::filter(subject=="11c.edf", trial=="23")
pup_g<- ggplot(interp_graph, aes(x= time, y= pupil)) + geom_point()+ geom_line(colour="black") + ggtitle("Raw Pupil Signal")
print(pup_g)
count_missing_pupil(pupil_blink_algo2, pupil="extendpupil")
d=count_missing_pupil(pupil, pupil="extendpupil")
d=count_missing_pupil(pupil_blink_algo2, pupil="pupil")
is.na(pupil_blink_algo2$extendpupil)
sum(is.na(pupil_blink_algo2$extendpupil))/length(pupil_blink_algo2)
sum(is.na(pupil_blink_algo2$extendpupil))/length(pupil_blink_algo2)*100
sum(is.na(pupil_blink_algo2$extendpupil))/length(pupil_blink_algo2)
sum(is.na(pupil_blink_algo2$extendpupil))
length(pupil_blink_algo2)
length(pupil_blink_algo2$extendpupil)
20/1294
pupil_blink_algo <-  interp_graph %>%
mutate(smooth_pupil=moving_average_pupil(pupil, n=10))
pup_g1<- ggplot(pupil_blink_algo, aes(x= time, y= smooth_pupil)) +
geom_point()+ geom_line(colour="black") + ylab=("Pupil")
pupil_blink_algo <-  interp_graph %>%
mutate(smooth_pupil=moving_average_pupil(pupil, n=10))
pup_g1<- ggplot(pupil_blink_algo, aes(x= time, y= smooth_pupil)) +
geom_point()+ geom_line(colour="black") + ylab=("Pupil") +
ggtitle("Smoothed Pupil Signal")
pupil_blink_algo <-  interp_graph %>%
mutate(smooth_pupil=moving_average_pupil(pupil, n=10))
pup_g1<- ggplot(pupil_blink_algo, aes(x= time, y= smooth_pupil)) +
geom_point()+ geom_line(colour="black") + labs(y = "Pupil") +
ggtitle("Smoothed Pupil Signal")
print(pup_g1)
blogdown
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::build_site()
This adaptation to R was made with the supervision and encouragement of Dr William Paul Boyce.
# For more information about this adaptation and for more R solutions, don't hesitate to contact him: paul.boyce@ntu.edu.sg
based_noise_blinks_detection <- function(pupil_data, sampling_rate_in_hz){
library(forecast)
library(ggplot2)
library(pracma)
sampling_interval     <- round(1000/sampling_rate_in_hz) #compute the sampling time interval in milliseconds.
gap_interval          <- 100 # set the interval between two sets that appear consecutively for concatenation.
blinks_data <- pupil_data==0
blinks <- c(-1*which(diff(blinks_data) %in% 1), which(diff(blinks_data) %in% -1)+1)
# Case 1: there are no blinks
if (length(blinks)==0)
return(blinks);
# Sort the blinks by absolute value. in this way we are getting an array of blinks when the offset appears after the onset
blinks <- blinks[order(abs(blinks))]
# Edge cases
# Case 2: the data starts with a blink. In this case, blink onset will be defined as the first missing value.
if (length(blinks)>0 && blinks[1]>0 && pupil_data[1]==0)
blinks = c(-1, blinks);
# Case 3: the data ends with a blink. In this case, blink offset will be defined as the last missing sample
if(length(blinks)>0 && tail(blinks, 1)<0 && tail(pupil_data, 1)==0)
blinks = c(blinks, nrow(pupil_data))
# Smoothing the data in order to increase the difference between the measurement noise and the eyelid signal.
ms_4_smooting  <- 10                                      # using a gap of 10 ms for the smoothing
samples2smooth <- ceiling(ms_4_smooting/sampling_interval) # amount of samples to smooth
smooth_data    <- ma(pupil_data, samples2smooth)
smooth_data[1, 1] <- pupil_data[1, 1]
smooth_data[2, 1] <- pupil_data[2, 1]
smooth_data[smooth_data==0] <- NaN;  # replace zeros with NaN values
diff_smooth_data            = diff(smooth_data);
# Finding the blinks' onset and offset
blink                 <- 1;                            # initialize blink index for iteration
blinks_data_positions <- matrix(0, length(blinks), 1)  # initialize the array of blinks
prev_offset           <- -1                            # initialize the previous blink offset (in order to detect consecutive sets)
while (blink < length(blinks)){
onset_candidate <- blinks[blink]
blink           <- blink + 1  # increase the value for the offset
# set the offset candidate
offset_candidate <- blinks[blink]
blink            <- blink + 1  # increase the value for the next blink
# find blink onset
data_before <- diff_smooth_data[2:abs(onset_candidate)] # returns all the data before the candidate
blink_onset <- tail(which(data_before>0), 1)            # returns the last 2 samples before the decline
# Case 2 (the data starts with a blink. In this case, blink onset will be defined as the first missing value.)
if (isempty(blink_onset==TRUE))
ifelse(onset_candidate == blinks[1], blink_onset <- 0, blink_onset <- -abs(onset_candidate))
# correct the onset if we are not in case 2
if (onset_candidate>0 || pupil_data[onset_candidate+2, 1]>0)
blink_onset      = blink_onset+2
# find blink offset
data_after   <- diff_smooth_data[abs(offset_candidate):length(diff_smooth_data)] # returns all data after the candidate
blink_offset  <- abs(offset_candidate)+head(which(data_after<0), 1)                   # returns the last sample before the pupil increase
# Case 3 (the data ends with a blink. In this case, blink offset will be defined as the last missing sample.)
if (length(blink_offset)==0)
blink_offset <- nrow(pupil_data)+1
# Set the onset to be equal to the previous offset in case where several sets of missing values are presented consecutively
if (sampling_interval*blink_onset > gap_interval && sampling_interval*blink_onset-sampling_interval*prev_offset<=gap_interval)
blink_onset <- prev_offset
prev_offset <- blink_offset-1
# insert the onset into the result array
blinks_data_positions[blink-2] <- -sampling_interval*blink_onset
# insert the offset into the result array
blinks_data_positions[blink-1] <- sampling_interval*(blink_offset-1)
}
duplicated_values     <- blinks_data_positions[duplicated(blinks_data_positions)]
#blinks_data_positions <- blinks_data_positions[!blinks_data_positions %in% duplicated_values];
res <- blinks_data_positions
id = 1;
while(id<length(res)-2)
{
if(res[id]>0 && res[id]==-res[id+1]){
toremove <- matrix(TRUE, length(res), 1);
toremove[id] <- FALSE
toremove[id+1] <- FALSE
res <- res[toremove]
}else{
id = id+1
}
}
return(abs(res))
}
d=based_noise_blinks_detection(interp_graph$pupil, 250)
d
d=based_noise_blinks_detection(as.matrix(interp_graph$pupil), 250)
d
df_blinks<-interp_graph%>%
# pass into a list
summarise(Blink_Index = list(based_noise_blinks_detection(as.matrix(PupilSize), 250))) %>%
unnest()
df_blinks<-interp_graph%>%
# pass into a list
summarise(Blink_Index = list(based_noise_blinks_detection(as.matrix(pupil), 250))) %>%
unnest()
df_blinks<-interp_graph%>%
# pass into a list
summarise(Blink_Index = list(based_noise_blinks_detection(as.matrix(pupil), 250))) %>%
unnest()
df_blinks
df_blinks<-interp_graph%>%
# pass into a list
summarise(cols=c(Blink_Index = list(based_noise_blinks_detection(as.matrix(pupil), 250))) %>%
unnest()
)
df_blinks<-interp_graph%>%
# pass into a list
summarise(cols=c(Blink_Index = list(based_noise_blinks_detection(as.matrix(pupil), 250))) %>%
unnest(c(Blink_Index))
)
df_blinks<-interp_graph%>%
# pass into a list
summarise(Blink_Index = list(based_noise_blinks_detection(as.matrix(pupil), 250))) %>%
unnest(c(Blink_Index))
df_blinks
blinks_data <- interp$pupil==0
blinks_data <- graph_interp$pupil==0
blinks_data <- interp_graph$pupil==0
blinks_data
This adaptation to R was made with the supervision and encouragement of Dr William Paul Boyce.
# For more information about this adaptation and for more R solutions, don't hesitate to contact him: paul.boyce@ntu.edu.sg
based_noise_blinks_detection <- function(pupil_data, sampling_rate_in_hz){
library(forecast)
library(ggplot2)
library(pracma)
sampling_interval     <- round(1000/sampling_rate_in_hz) #compute the sampling time interval in milliseconds.
gap_interval          <- 100 # set the interval between two sets that appear consecutively for concatenation.
blinks_data <- is.na(pupil_data)==0
blinks <- c(-1*which(diff(blinks_data) %in% 1), which(diff(blinks_data) %in% -1)+1)
# Case 1: there are no blinks
if (length(blinks)==0)
return(blinks);
# Sort the blinks by absolute value. in this way we are getting an array of blinks when the offset appears after the onset
blinks <- blinks[order(abs(blinks))]
# Edge cases
# Case 2: the data starts with a blink. In this case, blink onset will be defined as the first missing value.
if (length(blinks)>0 && blinks[1]>0 && pupil_data[1]==0)
blinks = c(-1, blinks);
# Case 3: the data ends with a blink. In this case, blink offset will be defined as the last missing sample
if(length(blinks)>0 && tail(blinks, 1)<0 && tail(pupil_data, 1)==0)
blinks = c(blinks, nrow(pupil_data))
# Smoothing the data in order to increase the difference between the measurement noise and the eyelid signal.
ms_4_smooting  <- 10                                      # using a gap of 10 ms for the smoothing
samples2smooth <- ceiling(ms_4_smooting/sampling_interval) # amount of samples to smooth
smooth_data    <- ma(pupil_data, samples2smooth)
smooth_data[1, 1] <- pupil_data[1, 1]
smooth_data[2, 1] <- pupil_data[2, 1]
smooth_data[smooth_data==0] <- NaN;  # replace zeros with NaN values
diff_smooth_data            = diff(smooth_data);
# Finding the blinks' onset and offset
blink                 <- 1;                            # initialize blink index for iteration
blinks_data_positions <- matrix(0, length(blinks), 1)  # initialize the array of blinks
prev_offset           <- -1                            # initialize the previous blink offset (in order to detect consecutive sets)
while (blink < length(blinks)){
onset_candidate <- blinks[blink]
blink           <- blink + 1  # increase the value for the offset
# set the offset candidate
offset_candidate <- blinks[blink]
blink            <- blink + 1  # increase the value for the next blink
# find blink onset
data_before <- diff_smooth_data[2:abs(onset_candidate)] # returns all the data before the candidate
blink_onset <- tail(which(data_before>0), 1)            # returns the last 2 samples before the decline
# Case 2 (the data starts with a blink. In this case, blink onset will be defined as the first missing value.)
if (isempty(blink_onset==TRUE))
ifelse(onset_candidate == blinks[1], blink_onset <- 0, blink_onset <- -abs(onset_candidate))
# correct the onset if we are not in case 2
if (onset_candidate>0 || pupil_data[onset_candidate+2, 1]>0)
blink_onset      = blink_onset+2
# find blink offset
data_after   <- diff_smooth_data[abs(offset_candidate):length(diff_smooth_data)] # returns all data after the candidate
blink_offset  <- abs(offset_candidate)+head(which(data_after<0), 1)                   # returns the last sample before the pupil increase
# Case 3 (the data ends with a blink. In this case, blink offset will be defined as the last missing sample.)
if (length(blink_offset)==0)
blink_offset <- nrow(pupil_data)+1
# Set the onset to be equal to the previous offset in case where several sets of missing values are presented consecutively
if (sampling_interval*blink_onset > gap_interval && sampling_interval*blink_onset-sampling_interval*prev_offset<=gap_interval)
blink_onset <- prev_offset
prev_offset <- blink_offset-1
# insert the onset into the result array
blinks_data_positions[blink-2] <- -sampling_interval*blink_onset
# insert the offset into the result array
blinks_data_positions[blink-1] <- sampling_interval*(blink_offset-1)
}
duplicated_values     <- blinks_data_positions[duplicated(blinks_data_positions)]
#blinks_data_positions <- blinks_data_positions[!blinks_data_positions %in% duplicated_values];
res <- blinks_data_positions
id = 1;
while(id<length(res)-2)
{
if(res[id]>0 && res[id]==-res[id+1]){
toremove <- matrix(TRUE, length(res), 1);
toremove[id] <- FALSE
toremove[id+1] <- FALSE
res <- res[toremove]
}else{
id = id+1
}
}
return(abs(res))
}
df_blinks<-interp_graph%>%
# pass into a list
summarise(Blink_Index = list(based_noise_blinks_detection(as.matrix(pupil), 250))) %>%
unnest(c(Blink_Index))
df_blinks
Label indices onset/offset - should always end in 'offset'
df_blinks$Label <- rep(c("Onset", "Offset"), length.out=nrow(df_blinks))
# Code to map blink onset/offset index to original dataframe
# Solution found here: https://stackoverflow.com/a/53105626/2653210
i1 <- match(row.names(df), df_blinks$Blink_Index)
df[names(df_blinks)[1:2]] <- lapply(df_blinks[1:2], `[`, i1)
# list rows where "Onset" appears
which(df$Label=="Onset")
df_blinks
interp_graph
interp_graph <- pupil_files1  %>%
dplyr::filter(subject=="11c.edf", trial=="23")
pup_g<- ggplot(interp_graph, aes(x= time, y= pupil)) + geom_point()+ geom_line(colour="black") + ggtitle("Raw Pupil Signal") + labs(y="Raw Pupil")
print(pup_g)
Label indices onset/offset - should always end in 'offset'
df_blinks$Label <- rep(c("Onset", "Offset"), length.out=nrow(df_blinks))
# Code to map blink onset/offset index to original dataframe
# Solution found here: https://stackoverflow.com/a/53105626/2653210
i1 <- match(row.names(df), df_blinks$Blink_Index)
df[names(df_blinks)[1:2]] <- lapply(df_blinks[1:2], `[`, i1)
# list rows where "Onset" appears
which(df$Label=="Onset")
df_blinks<-interp_graph%>%
# pass into a list
summarise(Blink_Index = list(based_noise_blinks_detection(as.matrix(pupil), 250))) %>%
unnest(c(Blink_Index))
df_blinks
i1 <- match(row.names(df), df_blinks$Blink_Index)
i1
i1 <- match(row.names(interp_graph), df_blinks$Blink_Index)
i1
df[names(df_blinks)[1:2]] <- lapply(df_blinks[1:2], `[`, i1)
interp_graph[names(df_blinks)[1:2]] <- lapply(df_blinks[1:2], `[`, i1)
interp_graph[names(df_blinks)[1:2]] <- lapply(df_blinks[1:2], `[`, i1)
# Label indices onset/offset - should always end in 'offset'
df_blinks$Label <- rep(c("Onset", "Offset"), length.out=nrow(df_blinks))
df_blinks
interp_graph[names(df_blinks)[1:2]] <- lapply(df_blinks[1:2], `[`, i1)
interp_graph
interp_graph$Label
# list rows where "Onset" appears
which(df$Label=="Onset")
# list rows where "Onset" appears
which(interp_graph$Label=="Onset")
df_blinks
i1 <- match(row.names(df), df_blinks$Blink_Index)
i1
blinks_data <- ia.na(interp_graph$pupil)==0
blinks_data <- is.na(interp_graph$pupil)==0
blinks_data
blinks_data <- is.na(interp_graph$pupil)==0
blinks_data
interp_graph[is.na(pupil)]<-0
interp_graph[is.na(interp_graph$pupil)]<-0
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(0, diff(smooth_pupil)/diff(time)))
pupil_blink_algo1$velocity_pupil
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(diff(smooth_pupil)/diff(time), 0))
pupil_blink_algo1$velocity_pupil
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(diff(smooth_pupil), 0))
pupil_blink_algo1$velocity_pupil
interp_graph <- pupil_files1  %>%
dplyr::filter(subject=="11c.edf", trial=="1")
pup_g<- ggplot(interp_graph, aes(x= time, y= pupil)) + geom_point()+ geom_line(colour="black") + ggtitle("Raw Pupil Signal") + labs(y="Raw Pupil")
print(pup_g)
pupil_blink_algo <-  interp_graph %>%
mutate(smooth_pupil=moving_average_pupil(pupil, n=10))
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(0, diff(smooth_pupil)/diff(time)))
pupil_blink_algo1$velocity_pupil
pupil_blink_algo1
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(0, diff(smooth_pupil))
)
pupil_blink_algo1
pupil_blink_algo1$velocity_pupil
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(diff(smooth_pupil), 0)
)
pupil_blink_algo1$velocity_pupil
pupil_blink_algo1$pupil
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(diff(smooth_pupil)), 0)
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(0, diff(pupil)))
pupil_blink_algo1$pupil
pupil_blink_algo1$velocity_pupil
pupil_blink_algo1$smooth_pupil
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(pupil=ifelse(is.na(pupil), 0, pupil), velocity_pupil=c(0, diff(smooth_pupil)/diff(time)))
pupil_blink_algo1
pupil_blink_algo1$pupil
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(pupil=ifelse(is.na(pupil), 0, pupil), velocity_pupil=c(0, diff(smooth_pupil))
)
n= length(pupil_blink_algo1$pupil)
n
write.csv(pupil_blink_algo1, file="test.csv")
write.csv(pupil_blink_algo1, file="test2.csv")
neg.start <- which(pupil_blink_algo1$velocity_pupil <= -5)
neg.start
neg.start <- which(pupil_blink_algo1$velocity_pupil <= -5)[1]
neg.start
based_noise_blinks_detection()
?based_noise_blinks_detection()
print(based_noise_blinks_detection())
print(based_noise_blinks_detection())
d
interp_graph <- pupil_files1  %>%
dplyr::filter(subject=="11c.edf", trial=="2")
pup_g<- ggplot(interp_graph, aes(x= time, y= pupil)) + geom_point()+ geom_line(colour="black") + ggtitle("Raw Pupil Signal") + labs(y="Raw Pupil")
print(pup_g)
pupil_blink_algo <-  interp_graph %>%
mutate(smooth_pupil=moving_average_pupil(pupil, n=10))
pup_g1<- ggplot(pupil_blink_algo, aes(x= time, y= smooth_pupil)) +
geom_point()+ geom_line(colour="black") + labs(y = " Smoothed Pupil") +
ggtitle("Smoothed Pupil Signal")
print(pup_g1)
pupil_blink_algo1 <- pupil_blink_algo %>%
mutate(velocity_pupil=c(diff(smooth_pupil)/diff(time), 0))
pup_g2<- ggplot(pupil_blink_algo1, aes(x= time, y= velocity_pupil)) +
geom_point()+ geom_line(colour="black") + ylab("Pupil Speed") +
ggtitle("Pupil Velocity")
pup_g2
pupil_blink_algo2 <-  pupil_blink_algo1 %>%
# Thrid, set neg and pos threshold here we are using -5 and 5 (probably good idea to look at data)
mutate(blinks_onset_offset=ifelse(velocity_pupil <= -4 | velocity_pupil >= 4,
1, 0)) %>%
# Four turn pupil values 0 if blink detection coded as 1
mutate(blinks_pupil=ifelse(blinks_onset_offset==1, pupil==NA, pupil)) %>%
mutate(extendpupil=extend_blinks(blinks_pupil, fillback=10, fillforward=10, hz=250)) %>%
#interpolate
dplyr::mutate(interp = zoo::na.approx(extendpupil, na.rm = FALSE, rule=2))
pupil_blink_algo2$velocity_pupil
pupil_blink_algo2 <-  pupil_blink_algo1 %>%
# Thrid, set neg and pos threshold here we are using -5 and 5 (probably good idea to look at data)
mutate(blinks_onset_offset=ifelse(velocity_pupil <= -4 | velocity_pupil >= 4,
1, 0)) %>%
# Four turn pupil values 0 if blink detection coded as 1
mutate(blinks_pupil=ifelse(blinks_onset_offset==1, pupil==NA, pupil)) %>%
mutate(extendpupil=extend_blinks(blinks_pupil, fillback=10, fillforward=10, hz=250)) %>%
#interpolate
dplyr::mutate(interp = zoo::na.approx(extendpupil, na.rm = FALSE, rule=2))
pupil_blink_algo2$blinks_onset_offset
pup_g3 <- ggplot(pupil_blink_algo2, aes(x= time, y= interp)) +
geom_point()+ geom_line(colour="black") +
xlab("Time (ms)") +
ylab("Pupil") +
ggtitle("Interpolated Pupil Signal")
print(pup_g3)
pup_g4 <- ggplot(pupil_blink_algo2, aes(x= time, y= pupil)) +
geom_point()+ geom_line(colour="black") +
geom_line(aes(x=time, y=interp), colour="purple") +
xlab("Time (ms)") +
ylab("Pupil") +
ggtitle("Interpolated Pupil Signal")
print(pup_g4)
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
knitr::opts_chunk$set(echo = TRUE)
library(gazer)
library(purrr)
library(Rmisc)
library(magrittr)
library(ggstatsplot)
library(knitr)
library(tidyverse)
agg_subject<-read_csv("blog_data.csv")
agg_subject$subject<-as.factor(agg_subject$subject)
agg_subject$script<-as.factor(agg_subject$script)
agg_subject<-select(agg_subject, -X1)
cur1 <- subset(agg_subject, timebins <= 3500)
#runningSE <- cur1 %>%
# split(.$timebins) %>%
# map(~Rmisc::summarySEwithin(data = ., measurevar = "aggbaseline", withinvars = "script", idvar="subject"))
#WSCI <- map_df(runningSE, extract) %>%
#  mutate(Time = rep(unique(cur1$timebins), each = 2))
#Note, you'll have to change 2 to match the number of conditions
WSCI.plot <- ggplot(agg_subject,aes(x=timebins, y=aggbaseline, linetype=script, color=script), size=3) + stat_summary(fun.y = "mean", geom = "line",size = 1,aes(colour = NULL)) + geom_rect(xmin=1900, xmax=3056, ymin=-Inf, ymax=Inf,
color="grey20",
alpha=0.01,
inherit.aes = FALSE)
print(WSCI.plot)
library(blogdown)
blogdown::serve_site()
blogdown::build_site()
blogdown::build_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::build_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::build_site()
library(knitr)
knitr::include_graphics('assets/img/spider.jpg')
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::build_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::build_site()
